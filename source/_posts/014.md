---
title: React生命周期详谈
date: 2025-10-27 19:03:38
tags: [React, 前端]
categories: [React, 前端]
---

---

# 🌿 React 生命周期详解：从创建到销毁的完整旅程

在使用 React 构建组件化应用的过程中，我们经常会听到一个重要的概念——**生命周期（Lifecycle）**。
生命周期是指一个组件从**创建（Mounting）**、**更新（Updating）**到**卸载（Unmounting）**的整个过程。

React 在不同阶段提供了一系列 **生命周期方法（Lifecycle Methods）**，让我们有机会在合适的时机执行副作用操作，比如发起网络请求、操作 DOM、保存状态等。

---

## 🧩 一、React 生命周期总览

React 组件的生命周期可以分为三个阶段：

| 阶段                   | 说明                                       |
| ---------------------- | ------------------------------------------ |
| **挂载（Mounting）**   | 组件被创建并插入到 DOM 中                  |
| **更新（Updating）**   | 当组件的 state 或 props 发生变化时重新渲染 |
| **卸载（Unmounting）** | 组件从 DOM 中被移除                        |

对于类组件（Class Component）和函数组件（Function Component，Hooks），它们的生命周期表现有所不同。

---

## 🧱 二、类组件生命周期详解

React 16 之后，类组件的生命周期主要包括以下几个方法：

### 1. 挂载阶段

| 方法                                | 调用时机             | 用途                               |
| ----------------------------------- | -------------------- | ---------------------------------- |
| `constructor()`                     | 组件被创建时调用     | 初始化 state、绑定方法             |
| `static getDerivedStateFromProps()` | 在 `render()` 前调用 | 根据 props 更新 state              |
| `render()`                          | 渲染 UI              | 返回要显示的 JSX                   |
| `componentDidMount()`               | 组件挂载后调用       | 执行副作用（如请求数据、操作 DOM） |

**示例：**

```jsx
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    console.log('constructor');
  }

  componentDidMount() {
    console.log('componentDidMount');
    document.title = `Count: ${this.state.count}`;
  }

  render() {
    console.log('render');
    return <h1>{this.state.count}</h1>;
  }
}
```

📌 执行顺序：
`constructor → render → componentDidMount`

---

### 2. 更新阶段

当组件的 **props 或 state 发生变化** 时，组件会重新渲染。主要生命周期方法如下：

| 方法                                | 调用时机            | 用途                       |
| ----------------------------------- | ------------------- | -------------------------- |
| `static getDerivedStateFromProps()` | 每次渲染前调用      | 根据 props 更新 state      |
| `shouldComponentUpdate()`           | 决定是否重新渲染    | 性能优化                   |
| `render()`                          | 重新渲染组件        | 更新 UI                    |
| `getSnapshotBeforeUpdate()`         | 更新前获取 DOM 状态 | 如滚动位置等               |
| `componentDidUpdate()`              | 更新完成后调用      | 发起请求、操作更新后的 DOM |

**示例：**

```jsx
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    console.log('count 改变了');
  }
}
```

📌 执行顺序：
`getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate`

---

### 3. 卸载阶段

| 方法                     | 调用时机           | 用途                             |
| ------------------------ | ------------------ | -------------------------------- |
| `componentWillUnmount()` | 组件即将卸载时调用 | 清除定时器、取消订阅、释放资源等 |

**示例：**

```jsx
componentWillUnmount() {
  clearInterval(this.timer);
  console.log('组件被卸载');
}
```

---

## ⚛️ 三、函数组件的生命周期（Hooks）

函数组件没有传统的生命周期方法，而是通过 **React Hooks**（如 `useEffect`）实现相同的效果。

### 1. 模拟挂载和卸载

```jsx
import { useEffect } from 'react';

function Example() {
  useEffect(() => {
    console.log('组件挂载');
    return () => {
      console.log('组件卸载');
    };
  }, []);
}
```

📌 `useEffect` 第二个参数为 `[]` 时，等价于：

- `componentDidMount`
- `componentWillUnmount`

---

### 2. 模拟更新

```jsx
useEffect(() => {
  console.log('count 更新了');
}, [count]);
```

📌 当依赖项 `count` 改变时触发，等价于：

- `componentDidUpdate`

---

### 3. 多个 useEffect 拆分逻辑

在函数组件中，我们可以声明多个 `useEffect` 来分别管理不同的副作用逻辑：

```jsx
useEffect(() => {
  console.log('监听窗口大小变化');
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);

useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);
```

---

## 🧠 四、生命周期与 Fiber 架构的关系

React 16 引入了 **Fiber 架构**，它让生命周期的执行变得更“可中断”、“可恢复”。
这意味着：

- 某些生命周期方法（如 `componentWillMount`、`componentWillUpdate`）可能在异步渲染中被多次调用；
- 因此它们被标记为 **不安全生命周期（Unsafe Lifecycle）**。

推荐使用以下“安全生命周期”：

- ✅ `componentDidMount`
- ✅ `componentDidUpdate`
- ✅ `componentWillUnmount`
- ✅ `getDerivedStateFromProps`
- ✅ `getSnapshotBeforeUpdate`

---

## 🧩 五、生命周期对比图

以下是常见生命周期的执行顺序（简化版）：

```
挂载阶段：
constructor → getDerivedStateFromProps → render → componentDidMount

更新阶段：
getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate

卸载阶段：
componentWillUnmount
```

---

## 🔍 六、总结对比表

| 功能     | 类组件                    | 函数组件                            |
| -------- | ------------------------- | ----------------------------------- |
| 挂载     | `componentDidMount()`     | `useEffect(() => {...}, [])`        |
| 更新     | `componentDidUpdate()`    | `useEffect(() => {...}, [dep])`     |
| 卸载     | `componentWillUnmount()`  | `useEffect(() => return {...}, [])` |
| 性能优化 | `shouldComponentUpdate()` | `React.memo()`                      |

---

## 💬 七、结语

理解生命周期，是深入掌握 React 的关键。
在类组件中，我们通过生命周期方法控制组件行为；
而在函数组件中，我们用 `useEffect`、`useMemo`、`useLayoutEffect` 等 Hooks 来优雅地管理副作用。

掌握生命周期，你就能更好地：

- 控制组件的行为；
- 避免不必要的渲染；
- 编写更高效、更易维护的代码。
