---
title: 深入理解 React Fiber：重新定义的渲染引擎
date: 2025-10-27 14:27:43
tags: ['React', '前端']
categories: ['React', '前端']
---

---

# 深入理解 React Fiber：重新定义的渲染引擎

> React Fiber 是 React 16 引入的一次底层重构，它让 React 拥有了“可中断”、“可恢复”、“可分片”的渲染机制，使得复杂 UI 的渲染更高效、更流畅。

---

## 一、为什么要有 Fiber？

在 React 15 及之前的版本中，React 使用的是 **Stack Reconciler（栈调和算法）**。
它的最大问题是：**渲染过程是同步、不可中断的。**

当组件树很大、或更新量很高时（例如动画、大量数据渲染），一次渲染可能会持续几十毫秒甚至更久。
这会造成浏览器主线程被长时间占用，导致：

- 页面掉帧、卡顿；
- 用户交互延迟；
- 动画不流畅。

于是 React 团队决定从底层重写调和器，这就是 **Fiber Reconciler** 的诞生。

---

## 二、什么是 Fiber？

**Fiber 是 React 组件的“虚拟执行单元”**。
可以理解为：React 把组件渲染的工作切分成一个个“小任务”，每个小任务就是一个 Fiber。

每个 Fiber 其实是一个对象，代表了一个组件节点的工作单元，它保存了该组件在不同阶段所需的各种信息。

一个典型的 Fiber 对象结构如下（简化版）：

```js
const fiber = {
  type,            // 对应的组件类型（函数组件、类组件、DOM节点等）
  key,             // 用于 diff 的 key
  stateNode,       // 对应的真实 DOM 或组件实例
  child,           // 子 Fiber
  sibling,         // 兄弟 Fiber
  return,          // 父 Fiber
  pendingProps,    // 新的 props
  memoizedProps,   // 上一次渲染时的 props
  memoizedState,   // 上一次渲染时的 state
  alternate,       // 旧 Fiber，用于比较（diff）
  flags,           // 标记要执行的操作类型（插入、更新、删除等）
};
```

> 可以把 Fiber 看作一个链表结构的树，每个节点（Fiber）都有指向父节点、子节点和兄弟节点的引用，从而形成了一棵可遍历的 Fiber 树。

---

## 三、Fiber 的核心目标：可中断的渲染

Fiber 的设计目标之一就是让渲染过程可以 **分片执行**，即：

> 把一次长时间的渲染任务拆分成若干小任务，在每一小段任务之间检查是否有更高优先级的工作要做。

例如：

- 用户正在输入；
- 用户点击了按钮；
- 浏览器需要执行动画帧。

此时 React 可以 **暂停当前渲染任务，优先响应用户交互，再回来继续渲染。**

这种“时间切片”机制由 **Fiber 调度器（Scheduler）** 实现。

---

## 四、React Fiber 的运行阶段

React Fiber 的工作大致分为两个阶段：

### 1. **Render（调和）阶段**

- 也叫 **Reconciliation 阶段**；
- 是 **可中断的**；
- 主要任务是：

  - 比较新旧 Fiber 树；
  - 计算需要执行的更新；
  - 构建新的 Fiber 树。

此阶段会被分成小的工作单元（Fiber），可在空闲时间执行。

### 2. **Commit（提交）阶段**

- 是 **不可中断的**；
- 一次性执行所有更新操作；
- 把变更反映到真实 DOM 上。

> 简单理解：
> Render 阶段在“思考该怎么改”；
> Commit 阶段在“实际去改”。

---

## 五、时间切片（Time Slicing）机制

React Fiber 利用了浏览器的 `requestIdleCallback`（或更高效的 polyfill）机制来分配任务时间。

每执行完一个 Fiber 节点，React 都会判断：

> “我还有时间继续执行下一个任务吗？
> 还是该让出主线程给浏览器处理其他事？”

如果时间不够，就会**暂停**当前任务，并把状态记录下来，下次继续。

这就是所谓的 **“可中断、可恢复的渲染”**。

---

## 六、Fiber 与优先级调度

Fiber 还引入了 **优先级调度（Priority Scheduling）**。

React 会根据不同的更新类型分配不同优先级：

| 更新类型     | 示例            | 优先级 |
| ------------ | --------------- | ------ |
| 用户输入     | 输入框 onChange | 最高   |
| 动画帧更新   | 过渡动画        | 高     |
| 普通渲染     | 状态变更        | 中     |
| 低优先级任务 | 后台数据预加载  | 低     |

这样 React 就能 **优先保证用户交互的流畅性**。

---

## 七、Fiber 树的双缓存机制

React 内部维护了两棵 Fiber 树：

| 树名称           | 含义                    |
| ---------------- | ----------------------- |
| `current`        | 当前正在显示的 Fiber 树 |
| `workInProgress` | 正在构建的新 Fiber 树   |

当新的树构建完毕后，会在 **commit 阶段** 用 `workInProgress` 替换掉 `current`。
这种“双缓存机制（Double Buffering）”保证了 UI 渲染的一致性与原子性。

---

## 八、Fiber 的意义

React Fiber 带来了几个重要的改进：

1. **可中断更新**
   避免长任务阻塞主线程。

2. **可恢复渲染**
   渲染可暂停、可恢复，不再“一口气跑完”。

3. **优先级调度**
   交互任务优先，让 UI 更流畅。

4. **渐进渲染**
   大型组件树可分阶段渲染。

5. **并发模式（Concurrent Mode）**
   为 React 18 的并发特性（如 `useTransition`、`Suspense`）打下基础。

---

## 九、总结

React Fiber 并不是一个新功能，而是一次底层架构的彻底重构。

它的意义在于：

- 让 React 从“同步渲染”变为“可调度渲染”；
- 从“递归调用”变为“链式遍历”；
- 从“单任务”变为“多优先级并行任务”。

> 简而言之，**Fiber 是 React 为了让 UI 更顺滑、更智能的一次架构革新。**

---
