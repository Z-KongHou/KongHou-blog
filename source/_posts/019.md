---
title: 关于我在 2025/11 的面试总结与反思
date: 2025-11-03 15:23:54
tags: [前端，面试记录]
categories: [面试经历]
---

# 2025.11 面经

少年当心中有志，而后能行远

## 字节 懂车帝 一面

- 1 . ES6 新增了哪些数据结构

  - Map
  - WeakMap
  - Set
  - WeakSet
    由于可能太紧张当时只回答了 Set

    > Map , WeakSet , WeakMap 有了解过吗
    >
    > - Map 是 ES6 新增的一种键值对集合，类似于 Object，但是值可以有各种类型
    > - WeakMap 与 Map 类似，但是其键只能是对象，并且是弱引用，不会阻止垃圾回收
    > - WeakSet 类似于 Set，但是成员只能是弱引用的对象
    >   另外因为 WeakMap 和 WeakSet 是弱引用，随时可能会被 GC 回收，故而被设计成不可枚举

- 2 . 对于数据的遍历，平常采用哪些方式

  - while , for , for...in... ,for...of...
  - map() , reduce() , filter() , forEach()
  - Object.keys() , Object.values() , Object.entries()

    > 假如要发 100 个请求，是串行的需要 async，这时候要用到哪种循环方法
    >
    > - 采用 for 或者 for...of... 配合 await 进行遍历
    > - 不能采用 forEach() , map() 因为其为函数式回调，不会等待请求执行

- 3 . 如何判断 call , apply , bind 函数 this 指向的执行逻辑

  - call , apply , bind 都可以显示改变 this 指向为其执行逻辑的第一个参数，若为 null 或者 undefined , 则在非严格模式下指向全局对象 window , 严格模式下指向 undefined。另外，箭头函数没有 this ，箭头函数的 this 只与其所在的外作用域有关，没办法通过这类方法改变

    > apply 和 call 的区别主要在于？
    >
    > - apply 和 call 的区别仅在传入参数的方式上，apply 接收一个对象对于 this 指向，而后接收一个数组作为 function 的参数列表，call 接收的是一系列参数，第一个参数依然是一个对象用于 function 的 this ，但后续的所有参数都将作为 function 的 arguments
    > - 而 apply 与 call 的使用上没有区别，都是基于某一个函数，改变 this 指向为需要的对象后调用这个函数

- 4 . 使用 React 时，主要用到了哪些 hooks

  - useEffect , useState , useCallback , useMemo

    > 要定义一个不期望去影响渲染的变量时，该使用哪一种 hook
    >
    > - useRef : useRef 返回的对象在组件整个生命周期里都是同一个引用，改 current 不会触发 reconcile，也不会让函数组件重新执行一遍。相比之下，useState 会触发调度器任务，造成无意义的 render，不符合‘不期望影响渲染’的题意。
    > - 凡是需要跨渲染、不触发 reconcile、又随时可读可写的数据——DOM 节点、定时器 id、上一次的值、昂贵实例、甚至强制刷新函数——都可以交给 useRef

- 5 . 在 hooks 里面能不能用一些判断语句来直接 return

  - 可以，hooks 规则只限定了 hook 的调用规则，并没有限制 hook 的执行逻辑 ，在 hook 里调用 return 只是把其内部的普通函数逻辑段落 , 只需要保证 hook 本身不在 条件调用语句当中即可

    > (ps: 笔者当时可能还是太紧张了，一听到条件就回答了不行，然后把 react hook 的底层逻辑扯了一遍，以为面试官问的是能不能在条件
    > 分支中写 hook)

  > 除了 React 官方的 hooks ，有去了解过，或者用过其他的 hooks 吗

- 6 . 当发现诉求和实现时有一定的额难度时，有考虑过使用 AI 工具来解决问题吗

  > 过去实现技术难点时，使用百度，Google 搜索，难以找到匹配的结果，在现如今还会使用搜索引擎还是 Kimi 之类的大模型沟通？

- 7 . 能介绍一下 koa 的洋葱模型吗

  - 核心思想是：中间件像一层一层洋葱皮，请求传过去再一层一层传出来执行剩余逻辑，即外层先进入，内层执行逻辑，再由外层回溯执行
  - await next() 是其执行的核心，如果中间哪一个中间件没有加，则其更内部的中间件将无法执行
  - 这种模型的好处主要在于方便外层统一日志，异常捕获，权限校验，在返回阶段可以统一做响应压缩，统一响应格式的工作

- 8 . git 有在用吗，使用时是基于 GUI 工具还是命令行 (具体指如何处理请求冲突)

- 9 . 编程题 ，实现一个 maxCalls 函数，在次数用完之前返回剩余次数，用完之后返回最后一次的执行结果，执行结果示例

```javascript
const limitedAdd = maxCalls((a, b) => a + b, 2); // 最多调用 2 次

console.log(limitedAdd(1, 1)); // 2
console.log(limitedAdd(1, 2)); // 3
console.log(limitedAdd(1, 3)); // 3
```

答案如示

```javascript
function maxCalls(func, maxTimes) {
  let count = maxTimes;
  let preResult;
  return (...args) => {
    if (count == 0) {
      return preResult;
    } else {
      count--;
      preResult = func(...args);
      return count;
    }
  };
}
```

### 总结

还是太紧张了，好几次理解错面试官到底想问什么，加上闭包函数写的太少，这个应该在五分钟内出结果的闭包题写了半个多小时还没写出来，准备不够充足，没有发挥应有实例，大概率是 g 了，实习是场长征路，继续沉淀，继续刷题
